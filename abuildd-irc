#!/usr/bin/env python3
# SPDX-License-Identifier: MIT
# Copyright (c) 2018 Max Rees
# See LICENSE for more information.
import asyncio
import signal
from logging import basicConfig

from hbmqtt.mqtt.constants import QOS_1
from PyIRC.signal import event as event_handler
from PyIRC.io.asyncio import IRCProtocol
from PyIRC.extensions import bot_recommended

from abuildd.config import GLOBAL_CONFIG
from abuildd.mqtt import init_mqtt, sanitize_message

basicConfig(level="DEBUG")

def _set_default(category, my_type):
    if my_type not in category:
        category[my_type] = []
    elif len(category[my_type]) == 1 and not category[my_type][0]:
        category[my_type] = []

class AbuilddIRCProtocol(IRCProtocol):  # pylint: disable=abstract-method
    def __init__(self, *args, chans=None, statuses=None, colors=False, **kwargs):
        self.colors = colors
        self.chans = chans or {}
        self.statuses = statuses or {}

        _set_default(self.chans, "builders")
        _set_default(self.chans, "jobs")
        _set_default(self.chans, "tasks")
        _set_default(self.chans, "cmd")
        _set_default(self.statuses, "builders")

        self.builders = {}
        kwargs["join"] = [chan for chans in self.chans.values() for chan in chans]

        super().__init__(*args, **kwargs)

    def get_builder_status(self, arches=None, name=None):
        if not arches:
            arches = self.builders.keys()
        elif not isinstance(arches, list):
            arches = [arches]

        arches = dict.fromkeys(arches)

        for arch in arches:
            arches[arch] = []

            if arch not in self.builders or not self.builders[arch]:
                continue

            for builder in self.builders[arch]:
                if name and builder != name:
                    continue

                status = self.builders[arch][builder]["status"]
                job = self.builders[arch][builder]["job"]
                task = self.builders[arch][builder]["task"]

                if self.colors:
                    s = f"\x02{builder}\x0f: {status}"
                else:
                    s = f"{builder}: {status}"

                if status != "offline" and job > 0 and task > 0:
                    s += f" with job {job} task {task}"

                arches[arch].append(s)

        return arches

    def cmd_status(self, recipient, nick, cmd):
        msg = [recipient, f"{nick}:"]

        if cmd[1] != "status":
            msg[1] += " usage: status [arch [name]] (get status of builder(s))"
            self.send("PRIVMSG", msg)
            return

        # <nick>: status
        if len(cmd) == 2:
            arch = None
            name = None
        # <nick>: status <arch>
        elif len(cmd) == 3:
            arch = cmd[2]
            name = None
        # <nick>: status <arch> <name>
        elif len(cmd) == 4:
            arch = cmd[2]
            name = cmd[3]

        statuses = self.get_builder_status(arch, name)
        for arch in statuses:
            if self.colors:
                msg[1] += f" \x02[{arch}]\x0f "
            else:
                msg[1] += f" [{arch}] "

            if statuses[arch]:
                msg[1] += ", ".join(statuses[arch])
            else:
                msg[1] += "(none)"

        if msg[1] == f"{nick}:":
            msg[1] += " no builders to be found"

        self.send("PRIVMSG", msg)

    @event_handler("commands", "PRIVMSG")
    def respond(self, _event, line):
        params = line.params
        nick = line.hostmask.nick

        if len(params) < 2:
            return

        recipient = params[0]
        for chan in self.chans["cmd"]:
            if self.casecmp(chan, recipient):
                break
        else:
            return

        cmd = params[-1].split()
        if len(cmd) < 2 or not cmd[0] or not cmd[1]:
            return

        if not self.casecmp(cmd[0].rstrip(":"), self.basic_rfc.nick):  # pylint: disable=no-member
            return

        cmdname = cmd[1].strip()

        if cmdname.startswith("status"):
            self.cmd_status(recipient, nick, cmd)

    @event_handler("abuildd", "builders")
    def announce_builders(self, _event, arch, name, data):
        if arch not in self.builders:
            self.builders[arch] = {}

        # Don't repeat ourselves
        if name in self.builders[arch]:
            if data == self.builders[arch][name]:
                return

        self.builders[arch][name] = data
        status = data["status"]
        job = data["job"]
        task = data["task"]

        if status not in self.statuses["builders"]:
            return

        if self.colors:
            msg = f"\x02[{arch}] {name}\x0f: {status}"
        else:
            msg = f"[{arch}] {name}: {status}"

        if status == "idle" and job > 0 and task > 0:
            msg += f" after completing job {job} task {task}"
        elif status != "offline" and job > 0 and task > 0:
            msg += f" with job {job} task {task}"

        for chan in self.chans["builders"]:
            self.send("PRIVMSG", [chan, msg])

    @event_handler("abuildd", "tasks")
    def announce_tasks(self, _event, arch, builder, task, data):
        data["arch"] = arch
        data["builder"] = builder
        data["task_id"] = task

        msg = data["project"]

        if data["status"] not in self.statuses["tasks"]:
            return

        if data["job_id"] <= 0 or data["task_id"] <= 0:
            return

        if data["event"] in ("note", "merge_request"):
            msg += " [MR #{mr_id} / branch {branch}]".format(**data)
        elif data["event"] == "push":
            msg += " [{branch} {commit_id}]".format(**data)

        if self.colors:
            msg += " \x02Job {job_id} task {task_id}:\x0f".format(**data)
        else:
            msg += " Job {job_id} task {task_id}:".format(**data)

        msg += " {repo}/{package} {version}".format(**data)
        msg += " {status} on {arch}/{builder}".format(**data)

        if data["status"] in ("rejected", "failure", "error"):
            msg2 = "Reason: {shortmsg}".format(**data)
        else:
            msg2 = None

        for chan in self.chans["tasks"]:
            self.send("PRIVMSG", [chan, msg])
            if msg2:
                self.send("PRIVMSG", [chan, msg2])

    @event_handler("abuildd", "jobs")
    def announce_jobs(self, _event, job, data):
        data["job_id"] = job
        msg = data["project"]

        if data["status"] not in self.statuses["jobs"]:
            return

        if data["job_id"] <= 0:
            return

        if data["event"] in ("note", "merge_request"):
            msg += " [MR #{mr_id} / branch {branch}]".format(**data)
        elif data["event"] == "push":
            msg += " [{branch} {commit_id}]".format(**data)

        if self.colors:
            msg += " \x02Job {job_id}:\x0f".format(**data)
        else:
            msg += " Job {job_id}:".format(**data)

        msg += " {status}".format(**data)

        if data["status"] in ("rejected", "failure", "error"):
            msg += " - {shortmsg}".format(**data)

        for chan in self.chans["tasks"]:
            self.send("PRIVMSG", [chan, msg])

def sigint(*protos):
    for proto in protos:
        try:
            proto.send("QUIT", ["Terminating due to ctrl-c!"])
            proto.close()
        except Exception:  # pylint: disable=broad-except
            pass

    print()
    print("Terminating due to ctrl-c!")

    quit()

async def handle_mqtt(irc, mqtt):
    while True:
        message = await mqtt.deliver_message()
        res = sanitize_message(message)
        # Only bother posting when we're all done connecting and joining
        if not res or not irc.registered:
            continue

        irc.call_event("abuildd", res[0], *res[1:])

# pylint: disable=invalid-name

proto_kwargs = {
    "serverport": (
        GLOBAL_CONFIG["irc"]["server"], GLOBAL_CONFIG.getint("irc", "port")
    ),
    "ssl": GLOBAL_CONFIG.getboolean("irc", "ssl"),
    "nick": GLOBAL_CONFIG["irc"]["nick"],
    "username": GLOBAL_CONFIG["irc"]["username"],
    "gecos": GLOBAL_CONFIG["irc"]["gecos"],
    "colors": GLOBAL_CONFIG.getboolean("irc", "colors"),
    "chans": {
        "builders": GLOBAL_CONFIG["irc"]["builders_chans"].split("\n"),
        "jobs": GLOBAL_CONFIG["irc"]["jobs_chans"].split("\n"),
        "tasks": GLOBAL_CONFIG["irc"]["tasks_chans"].split("\n"),
        "cmd": GLOBAL_CONFIG["irc"]["cmd_chans"].split("\n"),
    },
    "statuses": {
        "builders": GLOBAL_CONFIG["irc"]["builders_statuses"].split("\n"),
        "jobs": GLOBAL_CONFIG["irc"]["jobs_statuses"].split("\n"),
        "tasks": GLOBAL_CONFIG["irc"]["tasks_statuses"].split("\n"),
    },

    "extensions": bot_recommended,
}

topics = [
    ["builders/#", QOS_1],
    ["jobs/#", QOS_1],
    ["tasks/#", QOS_1],
]

irc_inst = AbuilddIRCProtocol(**proto_kwargs)
irc_conn = irc_inst.connect()

loop = asyncio.get_event_loop()
loop.add_signal_handler(signal.SIGINT, sigint, irc_inst)

mqtt_conn = loop.run_until_complete(
    init_mqtt(GLOBAL_CONFIG["irc"]["mqtt"], topics, loop=loop))
loop.run_until_complete(irc_inst.connect())
loop.create_task(handle_mqtt(irc_inst, mqtt_conn))
loop.run_forever()
loop.run_until_complete(mqtt_conn.close())
loop.close()
