#!/usr/bin/env python3
# SPDX-License-Identifier: MIT
# Copyright (c) 2018 Max Rees
# See LICENSE for more information.
# pylint: disable=invalid-name
import asyncio
import logging
import signal

from hbmqtt.mqtt.constants import QOS_1
from PyIRC.signal import event as event_handler
from PyIRC.io.asyncio import IRCProtocol
from PyIRC.extensions import bot_recommended

from abuildd.config import GLOBAL_CONFIG
from abuildd.connections import init_mqtt
from abuildd.events import Task
from abuildd.mqtt import sanitize_message

LOGGER = logging.getLogger("abuildd")
LOGGER.setLevel("DEBUG")
logging.basicConfig(format='%(asctime)-15s %(levelname)s %(message)s')

def _set_default(category, my_type):
    if my_type not in category:
        category[my_type] = []
    elif len(category[my_type]) == 1 and not category[my_type][0]:
        category[my_type] = []

class AbuilddIRCProtocol(IRCProtocol):  # pylint: disable=abstract-method
    def __init__(self, *args, chans=None, statuses=None, colors=False, **kwargs):
        self.colors = colors
        self.chans = chans or {}
        self.statuses = statuses or {}

        _set_default(self.chans, "builders")
        _set_default(self.chans, "events")
        _set_default(self.chans, "jobs")
        _set_default(self.chans, "tasks")
        _set_default(self.chans, "cmd")
        _set_default(self.statuses, "builders")

        self.more = []
        self.tasks = {}
        self.builders = {}
        kwargs["join"] = [chan for chans in self.chans.values() for chan in chans]

        if self.colors:
            self.bold = "\x02"
            self.reset = "\x0f"
        else:
            self.bold = ""
            self.reset = ""

        super().__init__(*args, **kwargs)

    def get_builder_status(self, arches=None, name=None):
        if not arches:
            arches = self.builders.keys()
        elif not isinstance(arches, list):
            arches = [arches]

        arches = dict.fromkeys(arches)

        for arch in arches:
            arches[arch] = []

            if arch not in self.builders or not self.builders[arch]:
                continue

            for builder in self.builders[arch]:
                if name and builder != name:
                    continue

                builder = self.builders[arch][builder]

                s = f"{self.bold}{builder.name}{self.reset}: {builder.status}"

                if builder.status == "idle" and builder.job > 0:
                    msg += f" after completing job #{builder.job}"
                elif (builder.status != "offline"
                      and builder.job > 0 and builder.task > 0):
                    msg += f" with job #{builder.job} task #{builder.task}"

                arches[arch].append(s)

        return arches

    @event_handler("botcmd", "status")
    def cmd_status(self, _event, recipient, cmd):
        msg = [recipient, ""]

        if len(cmd) > 3:
            msg[1] = "Usage: !status [arch [name]] (get status of builder(s))"
            self.send("PRIVMSG", msg)
            return

        # !status
        if len(cmd) == 1:
            arch = None
            name = None
        # !status <arch>
        elif len(cmd) == 2:
            arch = cmd[2]
            name = None
        # !status <arch> <name>
        elif len(cmd) == 3:
            arch = cmd[2]
            name = cmd[3]

        statuses = self.get_builder_status(arch, name)
        for arch in statuses:
            msg[1] += f" {self.bold}[{arch}]{self.reset} "

            if statuses[arch]:
                msg[1] += ", ".join(statuses[arch])
            else:
                msg[1] += " (none)"

        msg[1] = msg[1].strip()

        if not msg[1]:
            msg[1] = "No builders found"

        self.send("PRIVMSG", msg)

    @event_handler("botcmd", "tasks")
    def cmd_tasks(self, _event, recipient, cmd):
        msg = [recipient, ""]

        if len(cmd) != 2:
            msg[1] = "Usage: !tasks <job id> (get tasks associated with job)"
            self.send("PRIVMSG", msg)
            return

        try:
            job_id = int(cmd[1])
            tasks = self.tasks[job_id]
        except (ValueError, KeyError):
            msg[1] = "Invalid job ID"
            self.send("PRIVMSG", msg)
            return

        lines = [self.announce_tasks(task) for task in tasks]
        self.speak_with_restraint(recipient, lines)

    @event_handler("botcmd", "more")
    def cmd_more(self, _event, recipient, _cmd):
        self.speak_with_restraint(recipient, self.more)

    def speak_with_restraint(self, recipient, lines):
        for line in lines[:2]:
            self.send("PRIVMSG", [recipient, line])

        if len(lines) > 3:
            self.more = lines[3:]
            self.send("PRIVMSG", [recipient, "(use '!more' for more)"])

    @event_handler("commands", "PRIVMSG")
    def respond(self, _event, line):
        params = line.params

        if len(params) < 2:
            return

        recipient = params[0]
        for chan in self.chans["cmd"]:
            if self.casecmp(chan, recipient):
                break
        else:
            return

        cmd = params[-1].split()
        if not cmd or not cmd[0]:
            return

        if not cmd[0].startswith("!"):
            return

        cmdname = cmd[0].lstrip("!")
        self.call_event("botcmd", cmdname, recipient, cmd)

    def announce_builders(self, builder):
        if builder.arch not in self.builders:
            self.builders[builder.arch] = {}

        # Don't repeat ourselves
        if builder.name in self.builders[builder.arch]:
            if builder == self.builders[builder.arch][builder.name]:
                return None

        self.builders[builder.arch][builder.name] = builder

        if builder.status not in self.statuses["builders"]:
            return None

        msg = f"{self.bold}{builder.arch}/{builder.name}{self.reset}:"
        msg += f" {builder.status}"

        if builder.status == "idle" and builder.job > 0:
            msg += f" after completing job #{builder.job}"
        elif (builder.status != "offline"
              and builder.job > 0 and builder.task > 0):
            msg += f" with job #{builder.job} task #{builder.task}"

        return msg

    def announce_events(self, event):
        self.tasks = {}

        msg = f"[{event.project}] {event.user} created {event.status}"
        msg += f" {self.bold}event #{event.id}{self.reset}:"

        if event.category == "push":
            msg += f" {event.before}..{event.after}"
            msg += f" pushed to branch {event.branch}"
        elif event.category == "merge_request":
            msg += f" MR #{event.mr_id} for branch {event.branch}"
        elif event.category == "note":
            msg += f" note on MR #{event.mr_id}"

        if event.status in ("rejected", "failure", "error"):
            msg += f" - {event.shortmsg}"

        return msg

    def announce_jobs(self, job):
        msg = f"{self.bold}Job #{job.id}:{self.reset}"
        msg += f" {job.status} from event #{job.event_id}"
        msg += f" on {job.arch}/{job.builder} with {len(job.tasks)} tasks"

        if job.status in ("failure", "error"):
            msg += f" - {job.shortmsg}"

        self.tasks[job.id] = [Task.from_dict(task) for task in job.tasks]
        return msg

    def announce_tasks(self, task):
        msg = f"{self.bold}Task {task.id}:{self.reset}"

        msg += f" {task.repo}/{task.package} (version {task.version})"
        msg += f" {task.status}"

        if task.status in ("failure", "error"):
            msg += f" - {task.shortmsg}"

        return msg

def sigint(*protos):
    for proto in protos:
        try:
            proto.send("QUIT", ["Terminating due to ctrl-c!"])
            proto.close()
        except Exception:  # pylint: disable=broad-except
            pass

    print()
    print("Terminating due to ctrl-c!")

    quit()

async def handle_mqtt(irc, mqtt):
    while True:
        message = await mqtt.deliver_message()
        res = sanitize_message(message)
        # Only bother posting when we're all done connecting and joining
        if not res or not irc.registered:
            continue

        mtype, obj = res

        if mtype != "builders":
            if obj.status not in irc.statuses[mtype]:
                continue

            if obj.id <= 0:
                return

        formatter = getattr(irc, "announce_" + mtype)
        msg = formatter(obj)
        if not msg:
            continue

        for chan in irc.chans[mtype]:
            irc.send("PRIVMSG", [chan, msg])

proto_kwargs = {
    "serverport": (
        GLOBAL_CONFIG["irc"]["server"], GLOBAL_CONFIG.getint("irc", "port")
    ),
    "ssl": GLOBAL_CONFIG.getboolean("irc", "ssl"),
    "nick": GLOBAL_CONFIG["irc"]["nick"],
    "username": GLOBAL_CONFIG["irc"]["username"],
    "gecos": GLOBAL_CONFIG["irc"]["gecos"],
    "colors": GLOBAL_CONFIG.getboolean("irc", "colors"),
    "chans": {
        "builders": GLOBAL_CONFIG["irc"]["builders_chans"].split("\n"),
        "events": GLOBAL_CONFIG["irc"]["events_chans"].split("\n"),
        "jobs": GLOBAL_CONFIG["irc"]["jobs_chans"].split("\n"),
        "tasks": GLOBAL_CONFIG["irc"]["tasks_chans"].split("\n"),
        "cmd": GLOBAL_CONFIG["irc"]["cmd_chans"].split("\n"),
    },
    "statuses": {
        "builders": GLOBAL_CONFIG["irc"]["builders_statuses"].split("\n"),
        "events": GLOBAL_CONFIG["irc"]["events_statuses"].split("\n"),
        "jobs": GLOBAL_CONFIG["irc"]["jobs_statuses"].split("\n"),
        "tasks": GLOBAL_CONFIG["irc"]["tasks_statuses"].split("\n"),
    },

    "extensions": bot_recommended,
}

topics = [
    ["builders/#", QOS_1],
    ["events/#", QOS_1],
    ["jobs/#", QOS_1],
    ["tasks/+", QOS_1],
]

irc_inst = AbuilddIRCProtocol(**proto_kwargs)
irc_conn = irc_inst.connect()

loop = asyncio.get_event_loop()
loop.add_signal_handler(signal.SIGINT, sigint, irc_inst)

mqtt_conn = loop.run_until_complete(
    init_mqtt(GLOBAL_CONFIG["irc"]["mqtt"], topics, loop=loop))
loop.run_until_complete(irc_inst.connect())
loop.create_task(handle_mqtt(irc_inst, mqtt_conn))
loop.run_forever()
loop.run_until_complete(mqtt_conn.close())
loop.close()
