#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-2.0-only
# Copyright (c) 2019-2020 Max Rees
# See LICENSE for more information.
import argparse # ArgumentParser
import sys      # exit

import apkfoundry           # proj_conf
import apkfoundry.container # Container
import apkfoundry.digraph   # generate_graph
import apkfoundry._log as _log
import apkfoundry._util as _util

_log.init()

def print_graph(opts, graph):
    if opts.dot:
        print("digraph \"af-depgraph\" {")
        print("  rankdir=RL")
        print("  overlap=scale")
        def print_rel(dep, rdep):
            print(f"  \"{rdep}\" -> \"{dep}\"")
        for pkg in opts.startdirs:
            print(
                f"  \"{pkg}\"",
                "[ style=filled, fillcolor=blue, fontcolor=white ]",
            )

    else:
        def print_rel(dep, rdep):
            print(rdep, "->", dep)

    if opts.all_rdeps:
        for pkg in opts.startdirs[:]:
            opts.startdirs += graph.all_downstreams(pkg)
    elif opts.all_deps:
        for pkg in opts.startdirs[:]:
            opts.startdirs += graph.predecessors(pkg)

    if opts.rdeps or opts.all_rdeps:
        for pkg, rdeps in graph.graph.items():
            if opts.startdirs and pkg not in opts.startdirs:
                continue
            for rdep in rdeps:
                print_rel(pkg, rdep)

    elif opts.deps or opts.all_deps:
        for pkg, rdeps in graph.graph.items():
            for rdep in rdeps:
                if opts.startdirs and rdep not in opts.startdirs:
                    continue
                print_rel(pkg, rdep)

    else:
        for pkg, rdeps in graph.graph.items():
            if opts.startdirs and pkg not in opts.startdirs:
                continue

            if opts.dot:
                print(f"  \"{pkg}\"")

            for rdep in rdeps:
                if opts.startdirs and rdep not in opts.startdirs:
                    continue
                print_rel(pkg, rdep)

    if opts.dot:
        print("}")

def tsort(opts, graph):
    order = graph.topological_sort()
    if opts.startdirs:
        order = [i for i in order if i in opts.startdirs]
    print("\n".join(order))

def startdirs_arg(parser):
    parser.add_argument(
        "startdirs", metavar="STARTDIR", nargs="*",
        help="prune graph to examine only these STARTDIRs",
    )

def add_subcmd(parser, name, func=None, startdirs=True, **kwargs):
    subcmd = parser.add_parser(
        name, **kwargs,
        prog=f"af-depgraph [options ...] {name}",
    )
    if func:
        subcmd.set_defaults(func=func)
    if startdirs:
        startdirs_arg(subcmd)
    return subcmd

getopts = argparse.ArgumentParser(
    usage="af-depgraph [options ...] CMD [STARTDIR ...]",
)
getopts.add_argument(
    "-c", "--container", metavar="CDIR",
    help="execute inside container CDIR",
)
getopts.add_argument(
    "-s", "--skip-check", action="store_true",
    help="do not consider $checkdepends",
)
cmds = getopts.add_subparsers(
    metavar="CMD",
    help="subcommand to run",
)

cmd_graph = add_subcmd(
    cmds, "graph",
    help="print entire dependency graph",
    func=print_graph,
)
cmd_graph.add_argument(
    "-g", "--graphviz", dest="dot", action="store_true",
    help="print DOT output for Graphviz",
)
cmd_graph.add_argument(
    "-d", "--deps", action="store_true",
    help="print the dependencies of each STARTDIR",
)
cmd_graph.add_argument(
    "-D", "--all-deps", action="store_true",
    help="print all packages on which each STARTDIR ultimately depends",
)
cmd_graph.add_argument(
    "-r", "--rdeps", action="store_true",
    help="""print the packages which depend on each STARTDIR (i.e. the
    reverse dependencies)""",
)
cmd_graph.add_argument(
    "-R", "--all-rdeps", action="store_true",
    help="""print all packages which ultimately depend on each
    STARTDIR""",
)

add_subcmd(
    cmds, "acyclic",
    help="exit 0 if graph is acyclic only",
    func=lambda _, graph: sys.exit(0) if graph.is_acyclic() else sys.exit(2),
)
add_subcmd(
    cmds, "build-order",
    help="""consider STARTDIRs as a list of packages to build and output
    the topological sort build order""",
    func=tsort,
)
add_subcmd(
    cmds, "no-deps",
    help="print packages with no dependencies",
    func=lambda _, graph: print("\n".join(graph.ind_nodes())),
)
add_subcmd(
    cmds, "no-rdeps",
    help="print packages with no reverse dependencies",
    func=lambda _, graph: print("\n".join(graph.all_leaves())),
)

opts = getopts.parse_args()
if not hasattr(opts, "func"):
    getopts.print_help()
    sys.exit(1)

conf = apkfoundry.proj_conf(None, _util.get_branch())
if opts.container:
    cont = apkfoundry.container.Container(opts.container, sudo=False)
else:
    cont = None

graph = apkfoundry.digraph.generate_graph(
    conf, cont=cont,
    skip_check=opts.skip_check,
)
if graph is None:
    sys.exit(3)

opts.func(opts, graph)
