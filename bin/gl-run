#!/usr/bin/env python3
import base64
import logging
import os
import shutil
import sys
import tempfile
from os.path import relpath
from pathlib import Path

from apkfoundry import get_config, run, get_output, CI_Env, HOME, SITE_CONF
from apkfoundry import init_logger, msg2, section_start, section_end
from apkfoundry.build import run_job
from apkfoundry.container import cont_make, Container
from apkfoundry.socket import client_init

FAKE_BEFORE='0000000000000000000000000000000000000000'
SETARCH = get_config("setarch")
os.environ["USE_COLORS"] = "force"

init_logger(None, color=True, sections=True)

def changed_pkgs(before, after):
    pkgs = get_output(
        "git", "diff-tree", "-r", "--name-only", "--diff-filter", "dxu",
        f"{before}..{after}", "--", "*/*/APKBUILD",
    ).splitlines()
    return [i.replace("/APKBUILD", "") for i in pkgs]

def sanitize_script(script):
    run(
        "sed", "-i",
        "-e", f"s@{cdir}[/]*@/@g",
        "-e", "/AF_PRIVKEY/d",
        "-e", "/AF_PRIVKEY_B64/d",
        "-e", "/AF_PUBKEY/d",
        script,
    )

def get_keys():
    if "AF_PRIVKEY_B64" in ci_env and "AF_PUBKEY" in ci_env:
        privkey = ci_env["AF_PRIVKEY_B64"].strip()
        privkey = base64.b64decode(privkey)
        pubkey = ci_env["AF_PUBKEY"].strip()

        return privkey, pubkey

    if "AF_PRIVKEY" in ci_env:
        privkey = ci_env["AF_PRIVKEY"].strip()
        if "/" in privkey:
            logging.error("AF_PRIVKEY cannot contain slashes")
            return None, None

        privkey = Path(SITE_CONF / "keys" / project / privkey)
        if not privkey.is_file():
            logging.error("AF_PRIVKEY does not exist on this builder")
            return None, None

        pubkey = ci_env["AF_PUBKEY"].strip() if "AF_PUBKEY" in ci_env \
            else privkey.name + ".pub"
        privkey = privkey.read_bytes()

        return privkey, pubkey

    return None, None

def resignapk():
    if not privkey:
        return

    apks = list((cdir / "af/repos").glob("**/*.apk"))
    if not apks:
        return

    section_start(None, "resignapk", "Re-signing APKs...")
    with tempfile.NamedTemporaryFile() as tmp:
        tmp.write(privkey)
        tmp.flush()
        run(
            "fakeroot", "--",
            "resignapk", "-i",
            "-p", pubkey,
            "-k", tmp.name,
            *apks,
        )
    section_end(None)

def get_sources():
    run(script)

    if mr:
        os.chdir(aportsdir)
        run(
            "git", "fetch",
            target_url, 
            f"+refs/heads/{ref}:refs/heads/{ref}",
        )

    return 0

def build_script():
    os.chdir(aportsdir)

    shutil.copy2(script, cdir / "af/build_script")
    sanitize_script(cdir / "af/build_script")

    if mr:
        base = get_output("git", "merge-base", before, after)
        if not base or base == after:
            raise ValueError(f"Could not merge {after} into {ref}")

    manual_pkgs = []
    if "AF_PACKAGES" in ci_env:
        manual_pkgs = [i.strip() for i in ci_env["AF_PACKAGES"].split()]
        if manual_pkgs:
            section_start(None, "manual_pkgs", "The following packages were manually included:")
            msg2(None, manual_pkgs)
            section_end(None)

    section_start(None, "changed_pkgs", "Determining changed packages...")
    pkgs = []
    if before == FAKE_BEFORE:
        if manual_pkgs:
            logging.info("Manual job detected, skipping")
        else:
            logging.error("New branch detected, bailing out now")
    else:
        pkgs = changed_pkgs(before, after)
        if not pkgs:
            logging.error("No packages were changed")
        msg2(None, pkgs)
    section_end(None)

    if not pkgs and not manual_pkgs:
        return 0

    section_start(None, "bootstrap", "Bootstrapping container...")
    shutil.rmtree(aportsdir.with_suffix(".tmp"))
    aportsdir.with_suffix(".tmp").symlink_to(
        relpath(cdir / "tmp", aportsdir.parent
    ))


    cont_make(
        cdir,
        arch=arch,
        setarch=SETARCH.get(arch, None),
        repo=bootstrap_repo,
        cache=cache,
    )
    rc, conn = client_init(cdir, bootstrap=True)
    if rc != 0:
        logging.error("Failed to connect to rootd")
        return rc
    (aportsdir / ".gl-repos").symlink_to("../repos")
    section_end(None)

    return run_job(conn, cdir, [*pkgs, *manual_pkgs])

def after_script():
    shutil.copy2(script, cdir / "af/after_script")
    sanitize_script(cdir / "af/after_script")
    rc, conn = client_init(cdir)
    if rc != 0:
        logging.error("Failed to connect to rootd")
        return rc

    cont = Container(cdir, rootd_conn=conn)
    return cont.run(["/af/after_script"])[0]

script = sys.argv[1]
stage = sys.argv[2]

ci_env = CI_Env()
project = ci_env["CI_PROJECT_PATH_SLUG"]
cdir = Path(ci_env["CI_BUILDS_DIR"])
aportsdir = Path(ci_env["CI_PROJECT_DIR"])
before = ci_env["CI_COMMIT_BEFORE_SHA"]
after = ci_env["CI_COMMIT_SHA"]
ref = ci_env["CI_COMMIT_REF_NAME"]
mr = ci_env["CI_MERGE_REQUEST_ID"] if "CI_MERGE_REQUEST_ID" in ci_env else None

arch = ci_env["AF_ARCH"]
privkey, pubkey = get_keys()

if mr:
    target_url = ci_env["CI_MERGE_REQUEST_PROJECT_URL"]
    ref = ci_env["CI_MERGE_REQUEST_TARGET_BRANCH_NAME"]
    before = ref

cache = HOME / f"apk_cache/{ci_env['CI_PROJECT_PATH_SLUG']}.{ref}.{arch}"
cache.mkdir(exist_ok=True)
shutil.chown(cache, group="apkfoundry")
cache.chmod(0o2775)

if stage == "get_sources":
    rc = get_sources()

elif stage == "build_script":
    bootstrap_repo = aportsdir / ".apkfoundry/bootstrap-repo"
    bootstrap_repo = bootstrap_repo.read_text().strip()
    rc = build_script()
    keep = cdir / "af/info/keep"
    if rc:
        keep.touch(exist_ok=True)
    elif keep.is_file():
        keep.unlink()

elif stage == "after_script":
    resignapk()
    rc = after_script()

else:
    run(script)
    rc = 0

sys.exit(rc)
